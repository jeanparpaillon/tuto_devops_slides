
Objectives
    collaboration
    efficiency : automation
    safety (git)
    reliability (tests)

# Traditional approach (dev)
  
code archives
manual tests
custom deployment, per language
large documentation for deployment

# Tradtional approach (prod)
  
manual server administration, provisioning
lot of procedures
deploy applications on complex framework : J2EE, IIS, ...

# DevOps cycle : infinite loop diagram, containers at node

Dev
    develop
    validate
    test
    publish
    (release)
Prod
    develop
    validate
    test
    deploy

# Manage code versions : git

## git bases

### Exercises

Objective: initialise repository : devops_ex1
Do: git init
Observe: find .git

Objective: add new file, commit
Do: edit README.md
Observe: git status
Do: git add README.md
Observe: git status
Do: git commit 
Observe: 
    git log
    git status

## working with branches : merge

### Exercises
    
Objective: create a new branch : fix

Objective: add a new file and commit : TODO.md

Objective: merge branch into master
Observe: git log

## working with branches : rebase

### Exercises
    
Objective: create a new branch : fix2

Objective: add a new file and commit : LICENSE

Objective: edit README.md on master

Objective: rebase fix2 with master
Observe: git log

## working with tag

### Exercises
    
Objective: create a tag : exercise1

Objective: create a signed tag : v0.0.1

Objective: delete a tag : exercise1
Observe: git tag

## git: other commands

### Exercises
    
Objective: Git documentation
Do: git init --help
Do: git help init

Objective: History, test various output
Do: git log
Do: git help log

Objective: Understand git naming, ranges
Do: git log from..to | HEAD^^ | ...

# GitHub

Manage code and project with GitHub
Understand basic workflows 

Repo, Issues, Pull Request, Review, Branch protection

### Exercises
    
Objective: create repository
    
Objective: set it upstream for devops_ex1

Objective: create issue

Objective: 

## GitHub Actions

Automate code cycle from commit to artefact creation (docker)

Short presentation architecture (.github/), based on containers, basic syntax
Triggers : push, merge, but also timers, new tickets, etc

### Pre-requisite

Build basic nodejs web application, simple HTTP server 'Hello World'
Creates Docker container and push it on GitHub repo

### Exercises

Objective: Enable actions, choose existing workflows

Objective: ...

Objective: Ticket triggered action

# Artefact management

Store Docker containers, npm, python packages, ...
Depend on deployment methods
Applications can build several types of artefacts : npm package, doc, Docker container, ...

## Technology specific

Docker Hub, NPM, pypi, etc

## GitHub artefacts

# Artifactory

Global view
Integrates with vulnerabilities scanners, reports
Cache packages for speed AND blacklisting unsafe ones

## Repositories

Virtual
Cache
...

## Integration with SonarQube

## Integraton avec XRAY


##################################
##################################
#################################



## Formation dev

1. Versioning et GitHub
    1. Introduction
        1. Concepts de base
        2. Importance du Versioning
        3. Outils populaires
    2. git
        1. Commandes de base locales
            1. git init
            2. git add
            3. git commit
        2. Commandes distantes
            1. git push
            2. git pull
            3. git clone
    3. GitHub
        1. Création de dépôt
        2. Gestion des branches
        3. Pull Requests
        4. Code Review
    4. Collaboration avec GitHub
        1. Issues
        2. Projects
        3. Wikis
    5. Exercices
        1. Création d'un projet collaboratif
        2. Gestion de conflits de fusion
2. Intégration continue (CI) avec GitHub Actions
    1. Introduction CI
        1. Concepts de base
        2. Avantages
    2. Configuration GitHub Actions
        1. Création d'un workflow
        2. Déclencheurs
        3. Actions
    3. Automatisation des tests
    4. Personnalisation des workflows
        1. Utilisation des conditions
        2. Personnalisation des conteneurs
        3. Création d'actions personnalisées
    5. Déploiement continu (CD)
        1. Configuration des pipelines de déploiement
        2. Tests en environnement de production
    6. Exercices
        1. Mise en place d'un pipeline CI/CD complet
        2. Tests et déploiements automatiques
3. Artifactory, prise en main
    1. Introduction
        1. Présentation du production
        2. Gestion des artefacts et dépendances
    2. Installation et configuration
        1. Installation
        2. Configuration initiale
        3. Accès à l'interface utilisateur
    3. Interface utilisateur
        1. Exploration de l'UI
        2. Recherche des artefacts
        3. Gestion des artefacts
    4. Gestion des dépôts
        1. Dépôt NuGet
        2. Dépôt NPM
    5. Utilisation de XRAY
        1. Accès aux artefacts via XRAY
        2. Téléchargement des artefacts
    6. Exercices
        1. Création d'un dépôt NuGet
        2. Ajout des artefacts
        3. Gestion des artefacts
4. Configuration et Automatisation
    1. Configuration avancée
        1. Paramètres base de données
        2. Stockage basé sur des checksums
        3. Configuration des serveurs de fichiers
    2. Gestion des utilisateurs et permissions
        1. Création d'utilisateurs
        2. Attribution des permissions
        3. Gestion des groupes
    3. Intégration CI/CD
        1. Configuration des pipelines
        2. Intégration GitHub Actions
    4. Automatisation des flux de travail
        1. Création de workflows
        2. Automatisation des tests
        3. Automatisation des déploiements
    5. Exercices
        1. Création d'un pipeline CI/CD complet
        2. Tests automatiques
        3. Déploiements automatiques
    6. Sécurisation de l'infrastructure
        1. Configuration des règles de sécurité
        2. Gestion des secrets
        3. Durcissement des configurations
5. Configuration avancée
    1. Optimisation des performances
        1. Techniques d'optimisation
        2. Amélioration des performances
    2. Analyse et reporting
        1. Outils de reporting
        2. Analyse des performances
        3. Analyse des utilisations
    3. Mises à jour et maintenance
        1. Processus de mises à jour
        2. Gestion des correctifs
        3. Gestion des versions
    4. Cas d'utilisation avancés
        1. Études de cas
        2. Scénarios avancés
        3. Mise en œuvre

## Formation prod

### Jour 1 — Concepts de base & chaîne d'automatisation DevOps

_Objectif_ : Comprendre les fondations DevOps, les enjeux de l'automatisation de l'infrastructure à l'application, et les outils clés de la stack (VMware, Terraform, Kubernetes, Ansible).

_Contenu_

* Introduction à DevOps en production
    * Définition, objectifs (collaboration, vitesse, fiabilité)
    * Culture DevOps : CI/CD, infrastructure as code, observabilité
    * Rappels sur les environnements de production (exigences, contraintes)
* Chaîne d’automatisation complète : du hardware à l’application
    * Pourquoi automatiser ? Temps, fiabilité, traçabilité
    * Comparaison des approches traditionnelles vs DevOps
* Panorama des outils utilisés
    * VMware vSphere : virtualisation en environnement pro
    * Terraform : infrastructure as code
    * Kubernetes : orchestration de conteneurs
    * Ansible : configuration et déploiement applicatif
* Mise en place des prérequis
    * Présentation de l’environnement de lab (VMs, vSphere, K8s, etc.)
    * Installation des outils : Terraform, Ansible, kubectl, Helm
    * Préparation du projet Git (structure, branches, README)

### Jour 2 — Terraform : Infrastructure as Code

_Objectif_ : Maîtriser Terraform pour automatiser la création d'infrastructure (VMs) prête pour Kubernetes.

_Contenu_ :

* Introduction à Terraform
    * Fichiers .tf, providers, état
    * Syntaxe HCL : ressources, variables, outputs
    * Cycle de vie : init, plan, apply, destroy
* Providers
    * Provider vSphere : connexion, ressources, variables
    * Provider libvirt/QEMU pour environnement local
* Infrastructure cible
    * Schéma d'architecture cible (master, workers)
    * Réseau, stockage, DNS (selon le lab)
* Atelier pratique :
    * Écriture des fichiers Terraform pour créer les VMs
    * Provisionnement de 3 VMs (1 master, 2 workers)
    * Configuration cloud-init pour SSH et utilisateurs
    * Génération d'inventaire Ansible
    * Lancement, debug, validation
* Validation de l'infrastructure
    * Connectivité SSH aux VMs
    * Vérification des IPs et de l'inventaire
    * VMs prêtes pour installation K8s (Jour 3)

**Note**: Jour 2 se concentre uniquement sur Terraform. L'installation de Kubernetes sera réalisée au Jour 3 avec Ansible/Kubespray.

### Jour 3 — Ansible et Installation Kubernetes

_Objectif_ : Utiliser Ansible pour installer Kubernetes et déployer une application interne.

_Contenu_ :

* Introduction à Ansible
    * Inventaire, modules, rôles
    * Playbooks, variables, templates
    * Idempotence et bonnes pratiques
* Intégration Terraform → Ansible
    * Utilisation des outputs Terraform comme inventaire Ansible
    * Gestion dynamique de l'inventaire
* Installation de Kubernetes avec Kubespray
    * Introduction à Kubespray collection
    * Ansible Galaxy et requirements.yml
    * Configuration du cluster via playbooks
    * Installation de CNI (Calico, Flannel)
    * Validation : kubectl get nodes, kubectl get pods -A
* Déploiement d'une application intranet
    * Exemple : wiki, CRM interne, ou portail RH
    * Composants : base de données, backend, front
    * Déploiement sur K8s
* Création des rôles Ansible
    * Application : installation, configuration, services
* Déploiement automatisé
    * Exécution des playbooks
    * Gestion des secrets (vault)
    * Logs et vérifications post-déploiement
* Tests et validation fonctionnelle
    * Vérification des services
    * Connexion à l'application depuis le réseau interne
### Jour 4 — Déploiement d’une API/externe avec Ansible

_Objectif_ : Déployer une application accessible depuis l’extérieur, avec les enjeux de sécurité, exposition, scalabilité.

_Contenu_ :

* Spécificités d’une application externe
    * Authentification, certificats TLS, firewall, DNS
    * Observabilité, logs, alertes
* Préparation du déploiement
    * Configuration des ingress / load balancers
    * Gestion des certificats (cert-manager ou Ansible + Let’s Encrypt)
    * Variables d’environnement, secrets, vault
* Atelier : Déploiement d’une API REST
    * Stack type : NGINX + Flask/Django/FastAPI
    * Déploiement base de données + app + ingress
    * Tests d’accès extérieur (curl, navigateur)
* Intégration dans le pipeline
    * Déploiement automatique via GitOps ou hook CI/CD

### Jour 5 — Usages avancés : Monitoring, HA, sécurité, scaling

_Objectif_ : Consolider l’infrastructure pour la production avec des outils de supervision, de sécurité et de résilience.

_Contenu_ :

* Monitoring & Observabilité
    * Stack Prometheus + Grafana + Alertmanager
    * Collecte des logs (Loki, EFK, etc.)
    * Healthchecks & métriques Kubernetes
* Haute disponibilité
    * ÉtatfulSet, déploiement redondé
    * Anti-affinités, pod disruption budget
    * Architecture HA sur plusieurs zones/fournisseurs (conceptuellement)
* Sécurité
    * RBAC Kubernetes, gestion des droits d’accès
    * Scan de vulnérabilités (Trivy, kube-bench)
    * Chiffrement des secrets (Vault, Sealed Secrets)
* Scaling
    * HPA (Horizontal Pod Autoscaler)
    * Cluster autoscaler (si supporté par VMware)
    * Load balancers & tests de montée en charge (k6, Artillery)
* Conclusion de la formation
    * Debrief, retour sur les objectifs atteints
    * Pistes pour aller plus loin : GitOps, ArgoCD, CI/CD avancée